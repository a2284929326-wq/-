<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>圣诞树 | 摄像头优化版</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: sans-serif; }
        #loading-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #d4af37; font-size: 14px; transition: opacity 0.8s ease;
        }
        .spinner { width: 30px; height: 30px; border: 2px solid transparent; border-top: 2px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 100% { transform: rotate(360deg); } }
        #status-message { margin-top: 5px; opacity: 0.8; }
        #ui-hint {
            position: fixed; bottom: 20px; width: 100%; text-align: center;
            color: rgba(212,175,55,0.7); font-size: 12px; pointer-events: none;
        }
        #webcam { display: none; } /* 摄像头视频流隐藏在背景 */
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.mjs"
            }
        }
    </script>
</head>
<body>

<div id="loading-overlay">
    <div class="spinner"></div>
    <div id="status-message">正在加载核心场景...</div>
</div>

<div id="ui-hint">点击屏幕切换 | 尝试加载手势控制...</div>

<video id="webcam" autoplay playsinline></video>

<script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

    // 全局状态
    const STATE = {
        MODE: 'TREE', // TREE, SCATTER
        handLandmarker: null,
        isCameraReady: false,
        isAIActive: false,
        lastVideoTime: -1,
        touchControlEnabled: true // 默认开启触摸控制
    };

    let scene, camera, renderer, particles = [], mainGroup;
    let webcamElement;
    let loadingOverlay;
    let statusMessageElement;

    // --- 初始化 3D 场景 ---
    function initThree() {
        loadingOverlay = document.getElementById('loading-overlay');
        statusMessageElement = document.getElementById('status-message');
        webcamElement = document.getElementById('webcam');

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 45;

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        mainGroup = new THREE.Group();
        scene.add(mainGroup);
        scene.add(new THREE.AmbientLight(0xffffff, 1)); // 基础环境光

        // 创建 800 个粒子（降低性能开销）
        const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        for (let i = 0; i < 800; i++) {
            const material = new THREE.MeshBasicMaterial({
                color: i % 10 === 0 ? 0xffffff : 0xd4af37
            });
            const mesh = new THREE.Mesh(geometry, material);

            const t = i / 800;
            const angle = t * Math.PI * 40; // 螺旋更紧密
            const r = 10 * (1 - t);
            mesh.userData.treePos = new THREE.Vector3(
                Math.cos(angle) * r,
                t * 25 - 12, // 树高度
                Math.sin(angle) * r
            );

            mesh.userData.scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60
            );

            mesh.position.copy(mesh.userData.treePos);
            mainGroup.add(mesh);
            particles.push(mesh);
        }

        // 触摸控制 (默认启用)
        window.addEventListener('click', toggleMode);
        window.addEventListener('touchstart', toggleMode);

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // 移除加载层
        loadingOverlay.style.opacity = 0;
        setTimeout(() => loadingOverlay.remove(), 800);

        statusMessageElement.textContent = "正在尝试加载手势识别...";
        initAI(); // 场景加载后尝试启动 AI
        animate();
    }

    // 模式切换函数
    function toggleMode() {
        if (STATE.touchControlEnabled) { // 只有在触摸控制启用时才响应点击
            STATE.MODE = (STATE.MODE === 'TREE') ? 'SCATTER' : 'TREE';
        }
    }

    // --- 动画循环 ---
    async function animate() {
        requestAnimationFrame(animate);

        // 如果 AI 激活，进行手势检测
        if (STATE.isAIActive && STATE.isCameraReady) {
            const nowInMs = performance.now();
            if (webcamElement.currentTime !== STATE.lastVideoTime) {
                STATE.lastVideoTime = webcamElement.currentTime;
                const results = STATE.handLandmarker.detectForVideo(webcamElement, nowInMs);

                if (results.landmarks && results.landmarks[0]) {
                    const lm = results.landmarks[0];
                    const getDist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

                    const pinchDist = getDist(lm[8], lm[4]); // 拇指与食指
                    const avgTipDist = [8, 12, 16, 20].reduce((s, i) => s + getDist(lm[i], lm[0]), 0) / 4; // 指尖到手腕

                    // 根据手势切换模式
                    if (pinchDist < 0.05) STATE.MODE = 'TREE'; // 捏合->树
                    else if (avgTipDist < 0.25) STATE.MODE = 'SCATTER'; // 握拳->散开
                    else if (avgTipDist > 0.4) STATE.MODE = 'TREE'; // 张开->树
                    
                    // 手部位置控制旋转
                    mainGroup.rotation.y = THREE.MathUtils.lerp(mainGroup.rotation.y, (lm[9].x - 0.5) * Math.PI, 0.1);
                    mainGroup.rotation.x = THREE.MathUtils.lerp(mainGroup.rotation.x, (lm[9].y - 0.5) * Math.PI * 0.5, 0.1);

                    STATE.touchControlEnabled = false; // 手势控制生效后，禁用触摸切换
                    document.getElementById('ui-hint').textContent = "手势控制已激活！";
                } else {
                    STATE.touchControlEnabled = true; // 无手部数据，重新启用触摸
                    document.getElementById('ui-hint').textContent = "手势控制或点击屏幕切换状态";
                }
            }
        } else {
             STATE.touchControlEnabled = true; // AI 未激活时，确保触摸控制开启
        }

        // 更新粒子位置
        particles.forEach(p => {
            const target = (STATE.MODE === 'TREE') ? p.userData.treePos : p.userData.scatterPos;
            p.position.lerp(target, 0.08); // 更快的过渡
            p.rotation.x += 0.01;
            p.rotation.y += 0.01;
        });

        mainGroup.rotation.y += 0.002; // 整体轻微旋转
        renderer.render(scene, camera);
    }

    // --- 启动 AI 和摄像头 ---
    async function initAI() {
        try {
            // 尝试获取摄像头权限
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
            webcamElement.srcObject = stream;
            webcamElement.addEventListener('loadeddata', () => {
                STATE.isCameraReady = true;
                statusMessageElement.textContent = "正在下载AI模型...";
            });

            // 下载 MediaPipe AI 模型
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            STATE.handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/hand_landmarker.task", delegate: "GPU" },
                runningMode: "VIDEO", numHands: 1
            });
            STATE.isAIActive = true;
            document.getElementById('ui-hint').textContent = "手势控制已激活！";
            statusMessageElement.textContent = "AI加载成功！";

        } catch (e) {
            console.error("AI 或摄像头启动失败:", e);
            statusMessageElement.textContent = "AI加载失败，启用触摸控制。";
            document.getElementById('ui-hint').textContent = "手势控制加载失败，点击屏幕切换状态。";
            STATE.touchControlEnabled = true; // 确保触摸控制被激活
            STATE.isAIActive = false; // 标记 AI 未激活
        }
    }

    initThree();
</script>
</body>
</html>
