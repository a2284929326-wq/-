<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>金色圣诞树</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; }
        #hint {
            position: fixed; bottom: 30px; width: 100%; text-align: center;
            color: #d4af37; font-family: sans-serif; font-size: 14px;
            letter-spacing: 2px; opacity: 0.7; pointer-events: none;
        }
    </style>
    <script src="https://cdn.staticfile.org/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="hint">点击屏幕：聚拢 / 散开</div>

<script>
    let scene, camera, renderer, particles = [];
    let isTree = true;

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.z = 40;

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // 创建 1000 个金色粒子
        const geometry = new THREE.BoxGeometry(0.4, 0.4, 0.4);
        for (let i = 0; i < 1000; i++) {
            const material = new THREE.MeshBasicMaterial({ 
                color: i % 10 === 0 ? 0xffffff : 0xd4af37 
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // 计算圣诞树形态的位置
            const t = i / 1000;
            const angle = t * Math.PI * 30;
            const r = 12 * (1 - t);
            mesh.userData.treePos = new THREE.Vector3(
                Math.cos(angle) * r,
                t * 30 - 15,
                Math.sin(angle) * r
            );

            // 计算散开形态的位置
            mesh.userData.scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60
            );

            mesh.position.copy(mesh.userData.treePos);
            scene.add(mesh);
            particles.push(mesh);
        }

        // 点击事件：切换形态
        window.addEventListener('click', () => { isTree = !isTree; });
        window.addEventListener('touchstart', () => { isTree = !isTree; });

        animate();
    }

    function animate() {
        requestAnimationFrame(animate);
        
        particles.forEach(p => {
            const target = isTree ? p.userData.treePos : p.userData.scatterPos;
            p.position.lerp(target, 0.05); // 平滑过渡
            p.rotation.x += 0.02;
            p.rotation.y += 0.02;
        });

        scene.rotation.y += 0.005; // 整体旋转
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>
